```css raw
table {
    width: 100%;
    border-collapse: collapse;
    font-family: sans-serif;
    font-size: 14px;
    background-color: #fff;
    color: #333;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
}

th, td {
    border: 1px solid #ddd;
    padding: 6px 10px !important;
    text-align: left;
    vertical-align: middle;
}

th {
    background-color: #f4f4f4;
    font-weight: 600;
}

tr:nth-child(even) {
    background-color: #fafafa;
}

tr:hover {
    background-color: #f1f1f1;
}
```

```python exec
# This code makes the micropublication aware of its interface data.
from rocrate.rocrate import ROCrate
from dataclasses import dataclass
from types import SimpleNamespace
from datetime import datetime
import plotly.express as px
from typing import Optional
from pathlib import Path


import geopandas as gpd
import pandas as pd
import numpy as np
import requests
import folium
import json
import os
import re

# Load the id data
data_path = os.path.join(Path.cwd(), "data.json")
with open(data_path, 'r') as f:
    data = json.load(f)
site_id = data.get("id")
```

```python exec 
# Load the publication.crate, interface.crate, and batch_processes.crate manifest files (if available)
# For deployment, we primarily rely on cached data files
publication_crate_path = Path.cwd() 
interface_crate_path = Path.cwd() / "interface.crate" 
batch_processes_crate_path = interface_crate_path / "batch_processes"

# Check for cached data files
cached_shoreline_path = Path.cwd() / "cached_shoreline.geojson"
cached_primary_result_path = Path.cwd() / "cached_primary_result.geojson"

try:
    if publication_crate_path.exists() and interface_crate_path.exists() and batch_processes_crate_path.exists():
        publication_crate = ROCrate(publication_crate_path)
        interface_crate = ROCrate(interface_crate_path)
        batch_processes_crate = ROCrate(batch_processes_crate_path)
    else:
        print("Local crate files not found - using cached data files only")
        publication_crate = None
        interface_crate = None
        batch_processes_crate = None
except Exception as e:
    publication_crate = None
    interface_crate = None
    batch_processes_crate = None
    print(f"Error loading publication crate (will use cached data): {e}")
```

```python exec 
# Before narrative content, some helper functions to interface with the crates:
def query_by_link(crate, prop, target_id, match_substring=False):
    """
    Return entities (dict or ContextEntity) whose `prop` links to `target_id`.
    If `match_substring` is True, will return entities whose link includes `target_id` as a substring.
    """
    is_rocrate = hasattr(crate, "get_entities")
    entities = crate.get_entities() if is_rocrate else crate.get("@graph", [])
    out = []

    for e in entities:
        val = (e.properties().get(prop) if is_rocrate else e.get(prop))
        if val is None:
            continue
        vals = [val] if not isinstance(val, list) else val

        ids = [
            (x.id if hasattr(x, "id") else x.get("@id") if isinstance(x, dict) else x)
            for x in vals
        ]
        if match_substring:
            if any(target_id in _id for _id in ids if isinstance(_id, str)):
                out.append(e)
        else:
            if target_id in ids:
                out.append(e)
    return out

def filter_linked_entities_by_substring(crate, entities, prop, substring):
    """
    For a given list of entities, follow `prop` links (e.g., 'object') and return
    all linked entities whose `@id` includes `substring`.
    """
    is_rocrate = hasattr(crate, "get_entities")
    all_entities = crate.get_entities() if is_rocrate else crate.get("@graph", [])

    # Index entities by ID for fast lookup
    id_index = {
        (e.id if hasattr(e, "id") else e.get("@id")): e
        for e in all_entities
    }
    matched = []
    for entity in entities:
        val = entity.properties().get(prop) if is_rocrate else entity.get(prop)
        if val is None:
            continue

        vals = [val] if not isinstance(val, list) else val

        for v in vals:
            target_id = (
                v.id if hasattr(v, "id") else v.get("@id") if isinstance(v, dict) else v
            )

            if not isinstance(target_id, str):
                continue

            if substring in target_id:
                linked_entity = id_index.get(target_id)
                if linked_entity:
                    matched.append(linked_entity)

    return matched

def resolve_linked_entity(crate, entity, prop):
    """
    Follow a single-valued property (like 'instrument') from an entity,
    and return the linked entity (resolved from the crate).
    Returns None if the property is missing or not resolvable.
    """
    is_rocrate = hasattr(crate, "get_entities")
    all_entities = crate.get_entities() if is_rocrate else crate.get("@graph", [])

    # Build a lookup of @id to entity
    id_index = {
        (e.id if hasattr(e, "id") else e.get("@id")): e
        for e in all_entities
    }

    val = entity.properties().get(prop) if is_rocrate else entity.get(prop)
    if val is None:
        return None

    # Normalize to string ID
    if isinstance(val, list):
        raise ValueError(f"Expected only one linked entity in property '{prop}', but found a list.")
    
    target_id = (
        val.id if hasattr(val, "id") else val.get("@id") if isinstance(val, dict) else val
    )

    return id_index.get(target_id)

# And now helper general helper functions for data transofmation and narrative generation
def convert_to_raw_url(github_url: str) -> str:
    """
    Converts a GitHub blob URL to a raw.githubusercontent URL.
    """
    match = re.match(r"https://github\.com/(.+)/blob/([a-f0-9]+)/(.+)", github_url)
    if not match:
        raise ValueError("Invalid GitHub blob URL format.")
    user_repo, commit_hash, path = match.groups()
    return f"https://raw.githubusercontent.com/{user_repo}/{commit_hash}/{path}"

def get_location_name(geometry):
    """
    Get a human-readable location name from a shapely geometry using reverse geocoding.
    Uses the centroid of the geometry for the lookup.
    """
    try:
        # Get the centroid of the geometry
        centroid = geometry.centroid
        lon, lat = centroid.x, centroid.y
        
        location = requests.get(
            url="https://nominatim.openstreetmap.org/reverse",
            params={
                'lat': lat,
                'lon': lon,
                'format': 'json',
                'zoom': 10,
                'addressdetails': 1
            },
            headers={'User-Agent': 'CoastSat-shoreline-publication'}
        ).json().get('display_name')
        
        return location
    except Exception as e:
        print(f"Error getting location name: {e}")
        return "Unknown location"

def get_appended_rows(
    old_url: str,
    new_url: str,
    filter_column: str = None,
    filter_value: str = None
) -> pd.DataFrame:
    raw_old_url = convert_to_raw_url(old_url)
    raw_new_url = convert_to_raw_url(new_url)
    
    old_df = pd.read_csv(raw_old_url)
    new_df = pd.read_csv(raw_new_url)
    
    appended_df = pd.concat([new_df, old_df]).drop_duplicates(keep=False)

    # If you're looking for a particular transect column (e.g., 'sar0003-0003'),
    # this assumes the filter_column is in the wide format as a column name.
    if filter_column and filter_column in appended_df.columns:
        # Only keep rows where that transect column is not NaN
        appended_df = appended_df[~appended_df[filter_column].isna()]

    return appended_df
```

```python exec
# Get data for the site report - use cached data files
cached_shoreline_path = Path.cwd() / "cached_shoreline.geojson"
if cached_shoreline_path.exists():
    shoreline_gdf = gpd.read_file(cached_shoreline_path)
else:
    print("Error: No cached shoreline data found. Run publication_logic.py to cache data first.")
    raise FileNotFoundError("Cached shoreline data not found")

current_site_data = shoreline_gdf[shoreline_gdf['id'] == site_id] # Filter the shoreline data by the current site_id

# Now get the timeseries data for the site
time_series_data_by_site = query_by_link(interface_crate, "exampleOfWork", "#fp-transecttimeseriestidallycorrected-2")
site_time_series_entity = [
    e for e in time_series_data_by_site
    if site_id in (e.get("@id") if isinstance(e, dict) else getattr(e, "id", ""))
][0]  # Get the first match
site_time_series_url = convert_to_raw_url(site_time_series_entity["@id"]) if site_time_series_entity else None
# Download and load the site time series CSV data
if site_time_series_url:
    try:
        site_time_series_df = pd.read_csv(site_time_series_url)
    except Exception as e:
        print(f"Error loading site time series data: {e}")
        site_time_series_df = pd.DataFrame()
else:
    print("No site time series URL found.")
    site_time_series_df = pd.DataFrame()
```

```python exec
# Get location name in a separate block to avoid serialization issues
try:
    if len(current_site_data) > 0:
        geometry = current_site_data['geometry'].iloc[0]
        location_name = get_location_name(geometry)
    else:
        location_name = "No data found for this site"
except Exception as e:
    print(f"Warning: Could not get location name: {e}")
    location_name = "Unknown location"
```

```python exec
# Get data for the site report - use cached primary result data
cached_primary_result_path = Path.cwd() / "cached_primary_result.geojson"
if cached_primary_result_path.exists():
    primary_result_gdf = gpd.read_file(cached_primary_result_path)
else:
    print("Error: No cached primary result data found. Run publication_logic.py to cache data first.")
    raise FileNotFoundError("Cached primary result data not found")

site_primary_data = primary_result_gdf[primary_result_gdf['site_id'] == site_id]
```

# Site Report: `site_id`{python exec}
### Location: `location_name`{python exec}

> [!info]+ Site Statistics
> This table summarizes the key statistics for the site.
> ```python exec
> # Convert the DataFrame to a simple format for table display with units
> fields_to_keep = ['id', 'area', 'beach_length', 'easting', 'northing', 'median_slope']
> site_data_clean = current_site_data[fields_to_keep].reset_index(drop=True).copy()
> 
> # Apply formatting with units in a loop
> format_config = {
>     'area': (1000000, 3, ' km²'),
>     'beach_length': (1000, 2, ' km'),
>     'easting': (1000, 2, ' km'),
>     'northing': (1000, 2, ' km'),
>     'median_slope': (1, 4, '')
> }
>  
> for col, (divisor, decimals, unit) in format_config.items():
>     if col in site_data_clean.columns:
>         site_data_clean[col] = pd.to_numeric(site_data_clean[col], errors='coerce')
>         site_data_clean[col] = (site_data_clean[col] / divisor).round(decimals).astype(str) + unit
>  
> site_data_clean = site_data_clean.fillna('')
> site_data_clean
> ```

```python exec
# Import and run narrative zoning analysis
import sys
sys.path.insert(0, str(Path.cwd()))
from narrative_zoning import run_narrative_zoning

aoi_definitions =  {
    "No Data": {
        "priority": 1,
        "conditions": [
        {"field": "trend", "operator": "is_null", "value": None}
        ],
        "description_template": "No data zone where insufficient observations prevent trend analysis."
    },
    "Rapid Erosion": {
        "priority": 2,
        "conditions": [
        {"field": "trend", "operator": "<", "value": -0.8}
        ],
        "description_template": "Critical erosion hotspot with average retreat of {avg_trend_abs:.1f}m/year. This area requires immediate attention and monitoring."
    },
    "Moderate Erosion": {
        "priority": 3,
        "conditions": [
        {"field": "trend", "operator": "<", "value": -0.3}
        ],
        "description_template": "Erosion zone showing consistent retreat averaging {avg_trend_abs:.1f}m/year. Ongoing erosion processes are evident."
    },
    "Rapid Accretion": {
        "priority": 4,
        "conditions": [
        {"field": "trend", "operator": ">", "value": 0.8}
        ],
        "description_template": "Dynamic accretion zone with significant sand accumulation averaging {avg_trend:.1f}m/year. This area shows strong sediment deposition."
    },
    "Moderate Accretion": {
        "priority": 5,
        "conditions": [
        {"field": "trend", "operator": ">", "value": 0.3}
        ],
        "description_template": "Stable accretion zone with gradual beach building averaging {avg_trend:.1f}m/year. Positive sediment balance is maintained."
    },
    "High Uncertainty": {
        "priority": 6,
        "conditions": [
        {"field": "r2_score", "operator": "<", "value": 0.05, "allow_null": True},
        {"field": "rmse", "operator": ">", "value": 30, "allow_null": True}
        ],
        "logic": "OR",  # Either condition can trigger this zone
        "description_template": "Data-limited zone where shoreline trends are difficult to determine reliably. Additional monitoring may be needed."
    },
    "Steep Beach": {
        "priority": 7,
        "conditions": [
        {"field": "beach_slope", "operator": ">", "value": 0.08}
        ],
        "description_template": "High-energy beach zone characterized by steep beach profiles. This area may be vulnerable to storm impacts."
    },
    "Low Energy": {
        "priority": 8,
        "conditions": [
        {"field": "beach_slope", "operator": "<", "value": 0.04}
        ],
        "description_template": "Protected shoreline segment with gentle beach profiles indicating low wave energy conditions."
    },
    "Stable": {
        "priority": 9,
        "conditions": [],  # Default catch-all zone
        "description_template": "Stable shoreline segment showing minimal change over time. This area exhibits natural equilibrium."
    }
    }

min_zone_length = 3  # Minimum length in km for a zone to be considered valid
# Get areas of interest (AOIs) for the site
aois = run_narrative_zoning(site_id, cached_primary_result_path, min_zone_length=min_zone_length, zone_definitions=aoi_definitions)
aoi_zones = aois.get('zones', [])
all_transects = aois.get('transects', [])
```

::: if aoi_zones is not []

:::: for zone in aoi_zones

```python exec
def extract_zone_metrics(zone):
    def get(key, default=0, round_to=None):
        val = zone.get(key, default)
        if val is None:
            return "N/A"
        return round(val, round_to) if round_to is not None else val

    metrics = {
        "zone_type": zone.get("zone_type", "Unknown"),
        "length_km": round(abs(zone.get("length_meters", 0)) / 1000, 2),
        "mean_trend": get("mean_trend", 0, 2),
        "avg_beach_slope": get("avg_beach_slope", 0, 4),
        "r2_score": get("avg_r2", 0, 4),
        "avg_rmse": get("avg_rmse", None, 2),
        "avg_mae": get("avg_mae", None, 2),
        "avg_cil": get("avg_cil", None, 4),
        "avg_ciu": get("avg_ciu", None, 4),
        "avg_orientation": get("avg_orientation", None, 1),
        "narrative_description": zone.get("narrative_description", "No description available."),
        "transect_count": zone.get("transect_count", 0),
        "transect_ids": zone.get("transect_ids", []),
        "start_transect_id": zone.get("start_transect_id", "N/A"),
        "end_transect_id": zone.get("end_transect_id", "N/A"),
        "zone_name": zone.get("zone_name", "Unnamed Zone"),
    }

    return SimpleNamespace(**metrics)

zone_metrics = extract_zone_metrics(zone)
```

```python exec 
import geopandas as gpd
from shapely.geometry import LineString
import matplotlib.pyplot as plt
import contextily as cx  # Optional for basemap
import folium

def get_zone_transects(zone_metrics, all_transects):
    id_set = set(zone_metrics.transect_ids)
    results = []
    for tid, t in all_transects.items():
        if tid in id_set:
            t_copy = dict(t)
            t_copy["id"] = tid
            results.append(t_copy)
    return results

# Convert transects into a GeoDataFrame
def build_transect_gdf(transects):
    features = []
    for t in transects:
        coords = t["geometry"]["coordinates"]
        line = LineString(coords)
        features.append({
            "id": t["id"],
            "site_id": t.get("site_id"),
            "geometry": line
        })
    return gpd.GeoDataFrame(features, crs="EPSG:4326")

def save_zone_transect_map(zone_metrics, all_transects, out_path):
    zone_transects = get_zone_transects(zone_metrics, all_transects)
    gdf = build_transect_gdf(zone_transects)
    ax = gdf.plot(figsize=(6, 6), linewidth=2)
    cx.add_basemap(ax, crs="EPSG:4326")
    ax.set_title(f"Zone: {zone_metrics.zone_type}")
    ax.set_axis_off()
    plt.savefig(out_path, bbox_inches="tight")
    plt.close()

def save_interactive_transect_map(gdf, filename="zone_transects_map.html"):
    center = gdf.geometry.unary_union.centroid.coords[0][::-1]  # (lat, lon)
    m = folium.Map(location=center, zoom_start=12, tiles="OpenStreetMap")

    folium.GeoJson(
        gdf.to_json(),
        name="Transects",
        tooltip=folium.GeoJsonTooltip(fields=["id", "site_id"])
    ).add_to(m)

    map_path = os.path.join(dir, "zone_transects_map.html")
    m.save(map_path)
    return map_path

# TODO: Map stuff is waiting for integration 
zone_transects = get_zone_transects(zone_metrics, all_transects) # Zone_transects are used for more than just the map, so we keep them
# transect_gdf = build_transect_gdf(zone_transects)
# map_path = save_interactive_transect_map(transect_gdf)

```

<!--- ::: include zone_transects_map.html currently not working in Stencila --->

### Zone: `zone_metrics.zone_type`{python exec}

This zone spans `zone_metrics.length_km`{python exec} km and contains `zone_metrics.transect_count`{python exec} transects, from `zone_metrics.start_transect_id`{python exec} to `zone_metrics.end_transect_id`{python exec}.
`zone_metrics.narrative_description`{python exec}

:::: table 

`zone_metrics.zone_name`{python exec} Zone Metrics

| Metric      | Value                              |
|:-----------:|:----------------------------------:|
| **Length**      | `zone_metrics.length_km`{python exec} km         |
| **Mean Trend**  | `zone_metrics.mean_trend`{python exec} m/year    |
| **Beach Slope** | `zone_metrics.avg_beach_slope`{python exec}      |
| **R² Score**    | `zone_metrics.r2_score`{python exec}             |
::::

:::: table 

`zone_metrics.zone_name`{python exec} Zone Quality Metrics

| Metric            | Value                                      |
|:-----------------:|:------------------------------------------:|
| **RMSE**          | `zone_metrics.avg_rmse`{python exec} m        |
| **MAE**           | `zone_metrics.avg_mae`{python exec} m         |
| **Confidence Interval** | [`zone_metrics.avg_cil`{python exec}, `zone_metrics.avg_ciu`{python exec}] |
| **Orientation**   | `zone_metrics.avg_orientation`{python exec} °       |

::::

#### Transect Summaries

::::: if "nzd" in site_id

<!--- conditionals for plotly graphs --->
:::::: if zone_metrics.zone_type == "Moderate Erosion" or zone_metrics.zone_type == "Rapid Erosion"

```python exec
import plotly.graph_objects as go
import plotly.express as px
from datetime import datetime
import numpy as np
from scipy import stats

# Create a time series plot for the zone transects
if not site_time_series_df.empty and zone_transects:
    # Convert dates column to datetime if it's not already
    site_time_series_df['dates'] = pd.to_datetime(site_time_series_df['dates'])
    
    # Create the plotly figure
    fig = go.Figure()
    
    # Get transect IDs from zone_transects
    transect_ids = [transect['id'] for transect in zone_transects]
    
    # Colors for different transects (cycle through a color palette)
    colors = px.colors.qualitative.Set1
    
    # Collect all data to calculate zone-wide average baseline
    all_transect_data = []
    all_dates = set()
    
    # First pass: collect all data and find common dates
    valid_transects = []
    for transect_id in transect_ids:
        if transect_id in site_time_series_df.columns:
            transect_data = site_time_series_df[['dates', transect_id]].dropna()
            if not transect_data.empty:
                valid_transects.append((transect_id, transect_data))
                all_dates.update(transect_data['dates'])
    
    if valid_transects:
        # Calculate zone-wide average baseline from all transects
        all_values = []
        for transect_id, transect_data in valid_transects:
            all_values.extend(transect_data[transect_id].tolist())
        zone_mean_baseline = np.mean(all_values)
        
        # Calculate zone average time series
        all_dates_sorted = sorted(all_dates)
        zone_avg_values = []
        zone_dates = []
        
        for date in all_dates_sorted:
            date_values = []
            for transect_id, transect_data in valid_transects:
                matching_rows = transect_data[transect_data['dates'] == date]
                if not matching_rows.empty:
                    # Adjust relative to zone baseline
                    relative_val = matching_rows[transect_id].iloc[0] - zone_mean_baseline
                    date_values.append(relative_val)
            
            # Include ALL dates, even if only one transect has data (removed the restriction)
            if date_values:  # This will now include dates with any number of transects >= 1
                zone_avg_values.append(np.mean(date_values))
                zone_dates.append(date)
        
        # Add individual transect lines (lighter/thinner)
        for i, (transect_id, transect_data) in enumerate(valid_transects):
            relative_change = transect_data[transect_id] - zone_mean_baseline
            
            fig.add_trace(go.Scatter(
                x=transect_data['dates'],
                y=relative_change,
                mode='lines',
                name=f'{transect_id}',
                line=dict(color=colors[i % len(colors)], width=1),
                opacity=0.6,
                hovertemplate='%{fullData.name}: %{y:.1f}m<extra></extra>'
            ))
        
        # Add zone average line (prominent) with smoothing
        if zone_dates and zone_avg_values:
            # Apply rolling average smoothing to the zone average (6-month window)
            zone_df = pd.DataFrame({'dates': zone_dates, 'values': zone_avg_values})
            zone_df = zone_df.sort_values('dates')
            
            # Calculate rolling mean with a 6-month window (approximately 6 observations)
            window_size = min(6, len(zone_df) // 4)  # Adaptive window size
            if window_size >= 2:
                zone_df['smoothed'] = zone_df['values'].rolling(window=window_size, center=True, min_periods=1).mean()
                smoothed_values = zone_df['smoothed'].tolist()
            else:
                smoothed_values = zone_avg_values
            
            fig.add_trace(go.Scatter(
                x=zone_dates,
                y=smoothed_values,
                mode='lines+markers',
                name='Zone Average (Smoothed)',
                line=dict(color='black', width=3),
                marker=dict(size=4, color='black'),
                hovertemplate='Zone Average: %{y:.1f}m<extra></extra>'
            ))
            
            # Calculate and add single zone trendline
            if len(zone_dates) > 2:
                dates_numeric = pd.to_numeric(pd.Series(zone_dates))
                slope, intercept, r_value, p_value, std_err = stats.linregress(dates_numeric, zone_avg_values)
                
                # Generate trendline
                trend_y = slope * dates_numeric + intercept
                annual_rate = slope * 365.25 * 24 * 3600 * 1000  # Convert to m/year
                
                fig.add_trace(go.Scatter(
                    x=zone_dates,
                    y=trend_y,
                    mode='lines',
                    name=f'Zone Trend ({annual_rate:.1f} m/yr)',
                    line=dict(color='red', width=2, dash='dash'),
                    hovertemplate='Trend: %{y:.1f}m<extra></extra>'
                ))
    
    # Add baseline reference line at y=0
    fig.add_hline(y=0, line_dash="dot", line_color="gray", opacity=0.5,
                  annotation_text="Zone Baseline", 
                  annotation_position="bottom right")
    
    # Update layout with bottom legend
    fig.update_layout(
        title=f'Shoreline Position Time Series - {zone_metrics.zone_type} Zone<br><sub>Relative to zone mean baseline</sub>',
        xaxis_title='Date',
        yaxis_title='Cross-shore change [m]',
        hovermode='x unified',
        legend=dict(
            orientation="h",
            yanchor="top",
            y=-0.15,
            xanchor="center",
            x=0.5,
            font=dict(size=9)
        ),
        width=800,
        height=400,
        margin=dict(l=50, r=20, t=60, b=80),  # More bottom margin for legend
        font=dict(size=10)
    )
    
    # Add grid with light color and extend x-axis range for buffer
    fig.update_xaxes(showgrid=True, gridwidth=1, gridcolor='#eee')
    fig.update_yaxes(showgrid=True, gridwidth=1, gridcolor='#eee', hoverformat='.1f')
    
    # Ensure the latest data is always visible, prioritizing recent trends
    if zone_dates and len(zone_dates) > 1:
        end_date = pd.to_datetime(zone_dates[-1])   # Most recent date
        start_date = pd.to_datetime(zone_dates[0])  # Earliest date
        
        # Calculate total data span
        data_span_years = (end_date - start_date).days / 365.25
        
        # For long time series, show the most recent portion that fits well
        if data_span_years > 20:
            # Show last 20 years to ensure recent data is prominent
            view_start = end_date - pd.DateOffset(years=20)
            view_end = end_date + pd.DateOffset(years=1)
        else:
            # Show all data with small buffers
            view_start = start_date - pd.DateOffset(years=1)
            view_end = end_date + pd.DateOffset(years=1)
        
        fig.update_xaxes(range=[view_start, view_end])
    
    # Show the plot
    fig.show()
    
    print(f"Plotted {len(valid_transects)} transects from the {zone_metrics.zone_type} zone.")
    print(f"Zone baseline: {zone_mean_baseline:.1f}m (average of all transect means)")
else:
    print("No time series data available or no transects in zone.")
```

::::::
<!--- end of plotly conditional --->

:::::

::::

::: else

No areas of interest (AOIs) were found for the site.

:::

### Narrative Generation Configuration

#### Area of Interest (AOI) Definitions

```python exec
# simple mapping of opperators to their string representations
operator_to_english = {
    "<": "less than",
    "<=": "less than or equal to",
    ">": "greater than",
    ">=": "greater than or equal to",
    "==": "equal to",
    "!=": "not equal to",
    "is_null": "is null (missing)"
}
```

The area of interest (AOI) definitions are used to categorize shoreline segments based on their trends and characteristics. 
Each AOI has a priority, conditions for classification, and a description template for narrative generation.

This template returns zones with, at minimum, `min_zone_length`{python exec} transects.  

::: for aoi_def in aoi_definitions

> [!info]+ Area of Interest
> ### Title: **`aoi_def[0]`{python exec}**
> #### Priority: **`aoi_def[1]['priority']`{python exec}**
> 
> :::: if aoi_def[1]['conditions'] 
> 
> Conditions:
> 
> ::::: for condition in aoi_def[1]['conditions']
>
> :::::: if condition["value"] is not None
> 
> If the `condition['field']`{python exec} of the intersect is `operator_to_english[condition['operator']]`{python exec} than `condition['value']`{python exec}.
> 
> :::::: else 
>
> If the `condition['field']`{python exec} of the intersect `operator_to_english[condition['operator']]`{python exec}.
>
> ::::::
>
> :::::
> 
> ::::

:::